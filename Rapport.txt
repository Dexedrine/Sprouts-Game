Pseudo code de l'effacement de point dans le rond 

	On stock tout d'abord la coordonnée du point du debut de la ligne. 
	Pour chaque point de cette ligne allant du DebutDeLaLigne jusqu'a la coordonnée du bord du Point -1 
	{
		supprimer le pixel de la liste de point de la ligne
	}
	
	coordonneeX , coordonneeY = First.pos // on va mettre la position x et y dans les variables respective
	for point in ligne
		coorPointX = ligne[i *2]
		coorPointY = ligne[i*2 +1]
		if coorPointX < coordonneeX and coorPointY < coordonneeY:
			ligne.remove(i*2) // suppr x
			ligne.remove(i*2) // suppr y
	
	
	dans le on touch up on doit rajouter une verif : 
	
	root = self.parent
	for point in ligne:
		coorPointX = ligne[i *2]
		coorPointY = ligne[i*2 +1]
		for child in root.children:
           		if not isinstance(child, Point):
                		continue
                	if child == first or child == last:
                		continue
                	coordonneeX , coordonneeY = child.pos
                	if coorPointX < coordonneeX and coorPointY < coordonneeY:	
                		valid = false
                		break
         
/!\  attention : rajouter un objet LAST dans ligne  last = ObjectProperty
		mettre dans on_touch_up dans la variable last le point courant  : 
		if not child.collide_point(touch.x, touch.y):
                continue
                // on aura trouver le dernier noeud
                self.ligne.last = child
                
                //////
                //////
                

	    coordonneeX , coordonneeY = self.ligne.first.pos
	    print 'pos coorX = ' , coordonneeX , 'pos coorY', coordonneeY, 'range: ' , len(self.ligne.points) / 2
	    nbSuppression = 0
	    for point in range(len(self.ligne.points) / 2 - nbSuppression):
            	coorPointX = self.ligne.points[point*2 - nbSuppression]
		coorPointY = self.ligne.points[point*2 +1 - nbSuppression]
		print 'coorX = ' , coorPointX , 'coorY', coorPointY
		if coorPointX < coordonneeX +25 and coorPointX > coordonneeX-25 and coorPointY < coordonneeY +25 and coorPointY > coordonneeY-25:
			print ' on a supprimer les points !! '
			self.ligne.points.remove(coorPointX) # suppr x
			self.ligne.points.remove(coorPointY) # suppr y
			nbSuppression = nbSuppression +2
			
	    print 'fin de l algo foireux' 
 

	    
           


Durant la premier semaine nous avons decomposer le jeu en le separant  methodiquement en sous probleme 
Nous avons tout d'abord debattu sur le choix du langage , on a peser le pour et le contre au niveau du java ensuite on a debattu sur l'idée d'utiliser un langage dont on ne connaissait que tres peu mais qui était non seulement simple et concis. 

Ensuite nous avons evaluer les differentes classes possibles , nous avons ainsi creer la hierarchie de chaque classe
Nous avons reparti les taches de facon à diviser le temps de travail , chacun avait à resoudre un sous probleme 
Dans ce projet nous utilisons le frameworks Kivy qui est utiliser pour le rendu graphique


Pour echanger notre travail , nous avons choisi le site : github 

Ordre de resolution : 
 - Afficher un aspect graphique qui trace un certain nombre de point aleatoirement
 - Afficher le mouvement de souris de l'utilisateur sous forme d'un ensemble de point
 - amelioration pour afficher le tracer du mouvement de la souris de l'utilisateur sous forme d'une ligne continue
 - Tracer la ligne si et seulement si l'utilisateur relie deux points DISTINCT
 - Tracer la ligne en prenant en compte aussi le degres, le reliement au meme point
 - creation des bounding Box autour des lignes afin de les utiliser pour une optimisation ( recherche des xmax/min et ymax/min ) 
 - gerer la creation du nouveau point en s'appuyant sur la distance moyenne
 - Gerer le croisement de ligne
 - creation du menu 
 - creation du choix nombre de poiint au debut
 - empecher de traverser un point 
 
  
 A faire : 
 - selectionner le nombre de point de depart a creer// fini presque
 - gerer le systeme de score 
 - ajouter l'aspect graphique multijouer 
 - developper une interface client Serveur
 - determiner la fin du jeu
 - creation d'une IA
 - gerer la configuration du jeu , (son on/ off ) 
 - optimisation du jeu en utilisant les bounding box. 
 - centrer les points sur la ligne 
 - arrondi à faire pour le slider
 - enlever l'ensemble des points de la ligne lorque qu'il se trouve dans le noeud afin d'eviter les croisements de lignes inutile.   
 




outil utilisé, presentation ,  ce que l'on a fait  et ce que l'on doit faire
noté sur 25% note
cahier des charge des objectif ce que l'on pense a realisé
un diagramme des taches , modelisation et outil que l'on a utiliser




